{
  "hash": "9229d690cb500585c076307f0ef649c3",
  "result": {
    "engine": "knitr",
    "markdown": "---\noutput: html_document\neditor:\n    mode: source\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n# Best Practices for using eBird Data {#sec-ebird}\n\nEn este capítulo, destacaremos algunos de los desafíos asociados con el uso de datos de eBird. Luego mostraremos cómo importar los datos en R, aplicar filtros y usar listas completas para producir datos de detección/no detección adecuados para modelar la distribución y abundancia de especies. Finalmente, realizaremos algunos pasos de pre-procesamiento necesarios para asegurar el análisis apropiado de los datos.\\\nUsamos los términos **detección** y **no detección** en lugar de los términos más comunes **presencia** y **ausencia** a lo largo de esta guía para reflejar el hecho de que un conteo inferido de cero no necesariamente significa que una especie está ausente, solo que no fue detectada en la lista en cuestión.\n\n## Desafíos asociados con datos de eBird\n\nA pesar de las fortalezas de los datos de eBird, las observaciones de especies recolectadas a través de proyectos de ciencia ciudadana presentan una serie de desafíos que no se encuentran en datos científicos convencionales. Alguno de los siguientes desafíos asociados con estos datos que serán abordados a lo largo de este curso son:\n\n-   **Sesgo taxonómico**: los participantes a menudo tienen preferencias por ciertas especies, lo que puede llevar a un registro preferencial de algunas especies sobre otras ([Greenwood 2007](references.html#ref-greenwoodCitizensScienceBird2007); [Tulloch and Szabo 2012](#0)). Restringir los análisis a listas completas mitiga en gran medida este problema.\n\n-   **Sesgo espacial**: la mayoría de los participantes en proyectos de ciencia ciudadana muestrean cerca de sus hogares ([Luck et al. 2004](references.html#ref-luckAlleviatingSpatialConflict2004)), en áreas de fácil acceso como bordes de carreteras ([Kadmon, Farber, and Danin 2004](references.html#ref-kadmonEffectRoadsideBias2004)), o en áreas y hábitats de alta biodiversidad conocida ([Prendergast et al. 1993](references.html#ref-prendergastCorrectingVariationRecording1993)). Un método simple para reducir el sesgo espacial es crear una grilla sobre la región de interés y muestrear un número determinado de listas desde cada celda de la grilla.\n\n-   **Sesgo temporal**: los participantes muestrean preferentemente cuando están disponibles, como los fines de semana ([Courter et al. 2013](references.html#ref-courterWeekendBiasCitizen2013)), y en épocas del año cuando esperan observar más aves; notablemente, en Estados Unidos hay un gran aumento en envíos de eBird durante la migración de primavera ([Sullivan et al. 2014](references.html#ref-sullivanEBirdEnterpriseIntegrated2014)). Además, eBird ha aumentado constantemente en popularidad con el tiempo, lo que lleva a un fuerte sesgo hacia más datos en años recientes. Para abordar el sesgo de fin de semana, recomendamos usar una escala temporal de una semana o varias semanas para la mayoría de los análisis. Los sesgos temporales a escalas más largas pueden abordarse submuestreando los datos para producir una distribución temporal más uniforme.\n\n-   **Desbalance de clases**: las especies de aves que son raras o difíciles de detectar pueden tener datos con alto desbalance de clases, con muchas más listas con no detecciones que con detecciones. Para estas especies, un modelo de distribución que predice que la especie está ausente en todas partes tendrá alta precisión, pero ningún valor ecológico. Seguiremos los métodos para abordar el desbalance de clases propuestos por Robinson et al. ([2018](references.html#ref-robinsonUsingCitizenScience2018)), muestreando los datos para aumentar artificialmente la prevalencia de detecciones antes del modelado.\n\n-   **Precisión espacial**: la ubicación espacial de una lista de eBird se proporciona como un único punto latitud-longitud; sin embargo, esto puede no ser preciso por dos razones principales. Primero, para listas en tránsito, esta ubicación representa solo un punto en el recorrido. Segundo, las listas de eBird a menudo se asignan a un hotspot (una ubicación común para todos los observadores que visitan un sitio popular) en lugar de su ubicación verdadera. Por estas razones, no es apropiado alinear las ubicaciones de eBird con variables de hábitat muy precisas, y recomendamos resumir variables dentro de un vecindario alrededor de la ubicación de la lista.\n\n-   **Variación en detectabilidad/esfuerzo**: la detectabilidad describe la probabilidad de que una especie este presente en un área y sea detectada e identificada. La detectabilidad varía según la estación, hábitat y especie ([Johnston et al. 2014](references.html#ref-johnstonSpeciesTraitsExplain2014), [2018](references.html#ref-johnstonEstimatesObserverExpertise2018)). Además, los datos de eBird se recolectan con alta variación en esfuerzo, hora del día, número de observadores y condiciones externas como el clima, todo lo cual puede afectar la detectabilidad de las especies ([Ellis and Taylor 2018](references.html#ref-ellisEffectsWeatherTime2018); [Oliveira et al. 2018](references.html#ref-oliveiraObservationDiurnalSoaring2018)). Por lo tanto, la detectabilidad es particularmente importante de considerar al comparar entre estaciones, hábitats o especies. Dado que eBird usa un protocolo semi-estructurado que recolecta datos sobre el proceso de observación, podremos controlar una mayor proporción de esta variación en nuestros análisis.\n\nEl resto de esta guía demostrará cómo abordar estos desafíos usando datos reales de eBird para producir estimaciones confiables de distribuciones de especies. En general, tomaremos un enfoque de dos frentes para lidiar con datos no estructurados y maximizar el valor de los datos de ciencia ciudadana: **imponer más estructura en los datos mediante filtrado** e **incluir variables predictoras que describan el proceso de observación** en nuestros modelos para controlar la variación restante.\n\n## Importar datos de eBird en R {#sec-ebird-import}\n\nLa clase anterior aprendimos a descargar datos desde eBird, obteniendo dos archivos de texto separados por tabulaciones, uno para el EBD (datos de observación) y uno para el SED (datos de lista). Ahora, iniciaremos un nuevo proyecto de RStudio y agregaremos los dos archivos de texto descargados en el subdirectorio `data/` del directorio del proyecto.\n\nEl paquete de R `auk` está diseñado específicamente para trabajar con datos de eBird. Incluye las funciones [`read_ebd()`](https://cornelllabofornithology.github.io/auk/reference/read_ebd.html) and [`read_sampling()`](https://cornelllabofornithology.github.io/auk/reference/read_ebd.html) para importar el EBD y SED, respectivamente, en R.\n\nPrimero vamos a importar los datos de listas (SED).\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(auk)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(lubridate)\nlibrary(sf)\n\nf_sed <- \"data/ebd_CL-LL_chutap1_smp_relSep-2025_sampling.txt\" # aquí debemos ajustar el nombre del archivo si trabajaremos con una descarga personal\nchecklists <- read_sampling(f_sed, unique = FALSE) # leemos el archivo y generamos un objeto que contenga toda la información de las listas\nglimpse(checklists) # vemos un resumen rápido del objeto generado con la base de datos\n#> Rows: 135,787\n#> Columns: 33\n#> $ last_edited_date          <chr> \"2023-03-08 18:35:28.525811\", \"2023-03-08 18…\n#> $ country                   <chr> \"Chile\", \"Chile\", \"Chile\", \"Chile\", \"Chile\",…\n#> $ country_code              <chr> \"CL\", \"CL\", \"CL\", \"CL\", \"CL\", \"CL\", \"CL\", \"C…\n#> $ state                     <chr> \"Los Lagos\", \"Los Lagos\", \"Los Lagos\", \"Los …\n#> $ state_code                <chr> \"CL-LL\", \"CL-LL\", \"CL-LL\", \"CL-LL\", \"CL-LL\",…\n#> $ county                    <chr> \"Puerto Montt\", \"Curaco de Vélez\", \"Puerto V…\n#> $ county_code               <chr> \"CL-LL-OMO\", \"CL-LL-CUR\", \"CL-LL-OVA\", \"CL-L…\n#> $ iba_code                  <chr> NA, \"BIRDLIFE_26907\", NA, NA, NA, NA, NA, NA…\n#> $ bcr_code                  <int> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ usfws_code                <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ atlas_block               <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ locality                  <chr> \"piedra azul\", \"Curaco de Vélez--Humedales d…\n#> $ locality_id               <chr> \"L19884201\", \"L20235644\", \"L20552704\", \"L205…\n#> $ locality_type             <chr> \"P\", \"H\", \"P\", \"P\", \"P\", \"H\", \"H\", \"H\", \"H\",…\n#> $ latitude                  <dbl> -41.5, -42.4, -41.3, -42.9, -41.2, -41.3, -4…\n#> $ longitude                 <dbl> -72.8, -73.6, -72.9, -73.6, -74.1, -73.1, -7…\n#> $ observation_date          <date> 2019-08-15, 2019-01-24, 2019-02-16, 2019-02…\n#> $ time_observations_started <chr> \"08:00:00\", \"10:00:00\", \"17:08:00\", \"10:04:0…\n#> $ observer_id               <chr> \"obsr2818200\", \"obsr1166222\", \"obsr279749\", …\n#> $ observer_orcid_id         <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ sampling_event_identifier <chr> \"S114001497\", \"S118804608\", \"S116936975\", \"S…\n#> $ observation_type          <chr> \"Stationary\", \"Traveling\", \"Stationary\", \"St…\n#> $ protocol_name             <chr> \"Stationary\", \"Traveling\", \"Stationary\", \"St…\n#> $ protocol_code             <chr> \"P21\", \"P22\", \"P21\", \"P21\", \"P20\", \"P22\", \"P…\n#> $ project_names             <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ project_identifiers       <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ duration_minutes          <int> 480, 60, 5, 10, NA, 46, 36, 39, 12, 38, 124,…\n#> $ effort_distance_km        <dbl> NA, 1.000, NA, NA, NA, 0.253, 1.350, 0.270, …\n#> $ effort_area_ha            <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ number_observers          <int> 1, 1, 1, 1, NA, 4, 5, 4, 4, 4, 7, 3, 7, 4, 3…\n#> $ all_species_reported      <lgl> TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, T…\n#> $ group_identifier          <chr> NA, NA, NA, NA, NA, \"G4267503\", \"G4594512\", …\n#> $ checklist_comments        <chr> \"observada desde mi ventan en carretera aust…\n```\n:::\n\n\n\n\n::: callout-important\n## Checkpoint\n\nTómate un tiempo para explorar las variables en el conjunto de datos de listas. Si no estás seguro acerca de alguna de las variables, puedes consultar el documento pdf de metadatos que viene con la descarga de datos (`eBird_BaeBird_Basic_Dataset_Metadata_v1.16.pdf`) o con la versión en español que puedes encontrar en la carpeta drive del curso (`Manual-de-uso-base-de-datos-eBird-Chile-version-agosto-2025.pdf`).\n:::\n\nPara algunas aplicaciones, solo se requieren los datos de listas. Por ejemplo, los datos de listas se pueden usar para investigar la distribución espacial y temporal de datos eBird dentro de una región. Este conjunto de datos también puede ser útil para explorar cuánta variación hay en las variables de esfuerzo de observación e identificar listas que tienen baja precisión espacial o temporal.\n\n::: {.callout-caution icon=\"false\"}\n## Ejercicio\n\nRealiza un histograma que muestre la distribución de las distancias recorridas en las listas (checklist) con protocolo \"con desplazamiento\".\n:::\n\n::: {.callout-note icon=\"false\" collapse=\"true\"}\n## Solución\n\nCasi el 90% de las listas tienen menos de 10 km de longitud; sin embargo, algunas listas alcanzan hasta los 80 km en distancia. Las listas de verificación con largas distancias de viaje tienen una presición espacial menor, por lo que no suelen usarse en ciertos análisis y por lo tanto se eliminan antes de este.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nchecklists_traveling <- filter(checklists, protocol_name == \"Traveling\") #Aquí filtramos por el tipo de protocolo, en este caso, \"con desplazamiento\"\nggplot(checklists_traveling) +  # objeto con datos que queremos graficar\n  aes(x = effort_distance_km) + # variable que queremos en el eje x (distancia recorrida)\n  geom_histogram(binwidth = 5) + # ancho de los intervalos del histograma\n  scale_y_continuous(limits = c(0, NA), labels = scales::comma) + # ajustamos el eje y para que comience en 0 y formateamos los números con separador de miles\n  labs(x = \"Distance traveled [km]\", # etiqueta del eje x\n       y = \"# of eBird checklists\", # etiqueta del eje y\n       title = \"Distribución de la distancia recorrida en las listas de eBird\") # título del gráfico\n#> Warning: Removed 71 rows containing non-finite outside the scale range\n#> (`stat_bin()`).\n```\n\n::: {.cell-output-display}\n![](ebird_files/figure-html/ebird-import-distance-sol-1.png){fig-align='center' width=\\textwidth}\n:::\n:::\n\n\n\n:::\n\nPosiblemente notaron que en el ejercicio anterior les apareció la advertencia \"Removed 71 rows containing non-finite outside the scale range (`stat_bin()`).\". Este aviso nos indica que 71 filas de nuestra base de datos no fueron consideradas para el histograma porque el valor de `effort_distance_km` es no finito (`NA`, `NaN` o `Inf`). Esto no es grave, podemos revisar que ocurre con esas listas y corregir en caso de que sea necesario.\n\nAhora, importemos los datos de observación (EBD).\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf_ebd <- \"data/ebd_CL-LL_chutap1_smp_relSep-2025.txt\" #Aquí debemos ajustar el nombre del archivo si trabajaremos con una descarga personal\nobservations <- read_ebd(f_ebd, unique = FALSE, rollup = FALSE) # leemos el archivo y generamos un objeto que contenga toda la información de las listas\nglimpse(observations) # resumen rápido del objeto generado\n#> Rows: 21,792\n#> Columns: 52\n#> $ global_unique_identifier   <chr> \"URN:CornellLabOfOrnithology:EBIRD:OBS22384…\n#> $ last_edited_date           <chr> \"2024-10-14 12:41:13.045987\", \"2023-03-08 1…\n#> $ taxonomic_order            <int> 14232, 14232, 14232, 14232, 14232, 14232, 1…\n#> $ category                   <chr> \"species\", \"species\", \"species\", \"species\",…\n#> $ taxon_concept_id           <chr> \"avibase-23178B5E\", \"avibase-23178B5E\", \"av…\n#> $ common_name                <chr> \"Chucao Tapaculo\", \"Chucao Tapaculo\", \"Chuc…\n#> $ scientific_name            <chr> \"Scelorchilus rubecula\", \"Scelorchilus rube…\n#> $ subspecies_common_name     <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ subspecies_scientific_name <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ exotic_code                <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ observation_count          <chr> \"2\", \"1\", \"1\", \"1\", \"2\", \"4\", \"1\", \"3\", \"1\"…\n#> $ breeding_code              <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ breeding_category          <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ behavior_code              <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ age_sex                    <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ country                    <chr> \"Chile\", \"Chile\", \"Chile\", \"Chile\", \"Chile\"…\n#> $ country_code               <chr> \"CL\", \"CL\", \"CL\", \"CL\", \"CL\", \"CL\", \"CL\", \"…\n#> $ state                      <chr> \"Los Lagos\", \"Los Lagos\", \"Los Lagos\", \"Los…\n#> $ state_code                 <chr> \"CL-LL\", \"CL-LL\", \"CL-LL\", \"CL-LL\", \"CL-LL\"…\n#> $ county                     <chr> \"Ancud\", \"Ancud\", \"Ancud\", \"Ancud\", \"Ancud\"…\n#> $ county_code                <chr> \"CL-LL-ANC\", \"CL-LL-ANC\", \"CL-LL-ANC\", \"CL-…\n#> $ iba_code                   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ bcr_code                   <int> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ usfws_code                 <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ atlas_block                <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ locality                   <chr> \"Chiloe Island, first year, Rodrigo's\", \"Ch…\n#> $ locality_id                <chr> \"L2501072\", \"L2501072\", \"L2501072\", \"L25010…\n#> $ locality_type              <chr> \"P\", \"P\", \"P\", \"P\", \"P\", \"P\", \"P\", \"P\", \"P\"…\n#> $ latitude                   <dbl> -41.9, -41.9, -41.9, -41.9, -41.9, -41.9, -…\n#> $ longitude                  <dbl> -73.5, -73.5, -73.5, -73.5, -73.5, -73.5, -…\n#> $ observation_date           <date> 1994-10-25, 1994-11-08, 1994-11-26, 1994-1…\n#> $ time_observations_started  <chr> \"07:30:00\", \"07:30:00\", \"07:30:00\", \"07:30:…\n#> $ observer_id                <chr> \"obsr213338\", \"obsr213338\", \"obsr213338\", \"…\n#> $ observer_orcid_id          <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ sampling_event_identifier  <chr> \"S16187694\", \"S16187936\", \"S16188333\", \"S16…\n#> $ observation_type           <chr> \"Traveling\", \"Traveling\", \"Traveling\", \"Tra…\n#> $ protocol_name              <chr> \"Traveling\", \"Traveling\", \"Traveling\", \"Tra…\n#> $ protocol_code              <chr> \"P22\", \"P22\", \"P22\", \"P22\", \"P22\", \"P22\", \"…\n#> $ project_names              <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ project_identifiers        <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ duration_minutes           <int> 120, 240, 180, 300, 240, 300, 240, 300, 10,…\n#> $ effort_distance_km         <dbl> 8.05, 8.05, 6.44, 8.05, 8.05, 8.05, 32.19, …\n#> $ effort_area_ha             <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ number_observers           <int> 2, 2, 3, 2, 2, 2, 6, 2, 1, 2, 1, 3, 1, 3, 3…\n#> $ all_species_reported       <lgl> TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, T…\n#> $ group_identifier           <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ has_media                  <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, F…\n#> $ approved                   <lgl> TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, T…\n#> $ reviewed                   <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, F…\n#> $ reason                     <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ checklist_comments         <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ species_comments           <chr> \"courtship\", \"first nest! Chucao in & out, …\n```\n:::\n\n\n\n\n::: callout-important\n## Checkpoint\n\nTómate un tiempo para explorar las variables en el conjunto de datos de observación. Observa que el EBD duplica muchas de las variables a nivel de lista del SED.\n:::\n\nCuando leemos los datos en R, usamos `unique = FALSE` y `rollup = FALSE`. Por defecto, las funciones de lectura en el paquete `auk` realizan dos pasos importantes de preprocesamiento: combinar listas compartidas duplicadas y consolidación taxonómica. Intencionalmente desactivamos esta funcionalidad con fines demostrativos.\n\n### Listas compartidas {#sec-ebird-import-shared}\n\neBird permite a los usuarios [compartir listas](https://support.ebird.org/en/support/solutions/articles/48000625567-checklist-sharing-and-group-accounts#anchorShareChecklists) de verificación con otros observadores de su grupo, por ejemplo, [esta lista](https://ebird.org/checklist/S50445806) es compartida por 10 observadores. Estas listas se pueden identificar mirando la variable `group_identifier`, que asigna un ID que conecta todas las listas del grupo.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nchecklists %>%  # colocamos el objeto con el que queremos trabajar, en este caso la base de datos de los listados\n  filter(!is.na(group_identifier)) %>% # filtramos para quedarnos solo con las filas que presenten un ID de grupo \n  arrange(group_identifier) %>% # ordenamos las filas filtradas de menor a mayor, esto facilita la observación \n  select(sampling_event_identifier, group_identifier) # seleccionamos solo las columnas 'sampling_event_identifier' y 'group_identifier' para reducir la información a lo que necesitamos\n#> # A tibble: 59,623 × 2\n#>   sampling_event_identifier group_identifier\n#>   <chr>                     <chr>           \n#> 1 S133813900                G10000814       \n#> 2 S133813899                G10000814       \n#> 3 S133818644                G10001020       \n#> 4 S133818643                G10001020       \n#> 5 S133827106                G10001448       \n#> 6 S133962903                G10001448       \n#> # ℹ 59,617 more rows\n```\n:::\n\n\n\n\nLas listas con el mismo `group_identifier` proporcionan información duplicada sobre el mismo evento de observación de aves en la base de datos. Para la mayoría de los análisis, es importante contraer estas listas de verificación compartidas en una sola lista de verificación. Esto se puede lograr con la función [auk_unique()](https://cornelllabofornithology.github.io/auk/reference/auk_unique.html), que conserva solo una copia independiente de cada lista.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nchecklists_unique <- auk_unique(checklists, checklists_only = TRUE) # generamos un nuevo objeto que contenga solo una copia independiente de cada lista\nnrow(checklists) # número de filas en el objeto original\n#> [1] 135787\nnrow(checklists_unique) # número de filas en el nuevo objeto\n#> [1] 99730\n```\n:::\n\n\n\n\nObserve que se creó una nueva variable, `checklist_id`, que toma el valor de `group_identifier` para listas compartidas y de `sampling_event_identifier` para listas no compartidas.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhead(checklists_unique$checklist_id) # vemos los primeros seis valores de la columna checklist_id\n#> [1] \"S114001497\" \"S118804608\" \"S116936975\" \"S116936842\" \"S116974914\"\n#> [6] \"S53230567\"\ntail(checklists_unique$checklist_id) # vemos los ultimos seis valores de la columna checklist_id\n#> [1] \"G7616152\" \"G7628777\" \"G7626514\" \"G7634837\" \"G7636811\" \"G7637068\"\n```\n:::\n\n\n\n\n::: callout-tip\n## Tip\n\n¿Tienes curiosidad por saber qué listas y observadores contribuyeron a una lista compartida después de que se haya colapsado? El `sample_event_identifier` y el `observador_id` contienen listas separadas por comas de todas las listas y observadores que contribuyeron a las listas compartidas.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nchecklists_unique %>% # del objeto que no contiene duplicado\n  filter(checklist_id == \"G10045560\") %>% # filtramos las filas que correspondan a las listas del grupo \"G10045560\"\n  select(checklist_id, group_identifier, sampling_event_identifier, observer_id) \n#> # A tibble: 1 × 4\n#>   checklist_id group_identifier sampling_event_identifier            observer_id\n#>   <chr>        <chr>            <chr>                                <chr>      \n#> 1 G10045560    G10045560        S134565230,S134565692,S134660967,S1… obsr199389…\n# seleccionamos solo las columnas que nos interesan para saber que listas y observadores contribuyeron en la observación \n```\n:::\n\n\n\n:::\n\n### Rollup taxonómico {#sec-ebird-import-rollup}\n\nLas observaciones de eBird se pueden hacer a niveles por debajo de especie (por ejemplo, subespecie) o por encima de especie (por ejemplo, un ave que fue identificada como un pato, pero no se pudo determinar la especie); sin embargo, para la mayoría de los usos querremos observaciones a nivel de especie. Esto es especialmente cierto si queremos producir datos de detección/no detección a partir de listas completas, porque \"completo\" solo aplica a nivel de especie.\n\n::: callout-tip\n## Tip\n\nEn el conjunto de datos de ejemplo utilizado para este curso, estos problemas taxonómicos no se aplican. Hemos solicitado observaciones de chucao, por lo que no hemos recibido ninguna observación de taxones por encima de la especie, ni tampoco subespecies. Sin embargo, en muchas otras situaciones, estos problemas taxonómicos pueden ser importantes. Por ejemplo, [esta lista](https://ebird.org/checklist/S109437960) tiene 1 tijeral común y 1 tijeral común (aegithaloides). `auk_rollup()` combina las dos observaciones en una sola observación de tijeral común.\n:::\n\nLa función [auk_rollup()](https://cornelllabofornithology.github.io/auk/reference/auk_rollup.html) elimina todas las observaciones no identificables a nivel de especie y consolida todas las observaciones reportadas por debajo de especie al nivel de especie.\n\nPara este ejercicio trabajaremos con el tijeral, por lo que antes de realizar el rollup debemos cargar la base de datos del tijeral en Chile (`ebd_CL_pmtspi1_smp_relSep-2025.txt`).\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nft_ebd <- \"data/ebd_CL_pmtspi1_smp_relSep-2025.txt\"\ntijeral <- read_ebd(f_ebd, unique = FALSE, rollup = FALSE) \n\nobservations_rollup <- auk_rollup(tijeral)\n# uno de los ejemplos, revisamos la lista antes del rollup y comparamos con como queda la información luego del rollup. \ntijeral %>% \n  filter(sampling_event_identifier == \"S109437960\") %>% \n  select(sampling_event_identifier, common_name, subspecies_common_name, \n         observation_count)\n#> # A tibble: 0 × 4\n#> # ℹ 4 variables: sampling_event_identifier <chr>, common_name <chr>,\n#> #   subspecies_common_name <chr>, observation_count <chr>\nobservations_rollup %>% \n  filter(sampling_event_identifier == \"S109437960\") %>% \n  select(sampling_event_identifier, common_name,\n         observation_count)\n#> # A tibble: 0 × 3\n#> # ℹ 3 variables: sampling_event_identifier <chr>, common_name <chr>,\n#> #   observation_count <chr>\n```\n:::\n\n\n\n\n::: callout-tip\n## Tip\n\nSi múltiples taxones en una sola lista se consolidan a la misma especie, `auk_rollup()` intenta combinarlos inteligentemente. Si cada observación tiene un conteo, esos conteos se suman, pero si alguna de las observaciones carece de conteo (es decir, el conteo es \"X\") la observación combinada también recibe una \"X\". En la [lista de ejemplo](https://ebird.org/checklist/S109437960) del Tip anterior, con dos taxones consolidándose a tijeral común, `auk_rollup()` suma los dos conteos para obtener 2 tijeral común (1 + 1).\n:::\n\n## Generación de datos de detección/no detección {#sec-ebird-zf}\n\nLas listas completas de eBird son extremadamente valiosas porque, para todas las especies que no fueron reportadas, podemos inferir conteos de 0. Esto nos permite convertir datos de solo presencia a datos de detección/no detección, lo que nos permite realizar análisis mucho más robustos. Ten en cuenta que no usamos el término presencia/ausencia, porque una no detección no necesariamente implica que la especie estuvo ausente, solo que el observador no la detectó e identificó.\n\nNos referimos al proceso de producir datos de detección/no detección como \"llenar con ceros\" los datos de eBird (zero-filling), porque estamos llenando los ceros faltantes. Leeremos los datos de eBird en R nuevamente, y filtraremos solo las listas completas. Luego, usaremos la función [`auk_zerofill()`](https://cornelllabofornithology.github.io/auk/reference/auk_zerofill.html) para generar datos de detección/no detección. Ten en cuenta que las listas compartidas se combinan y la consolidación taxonómica se realiza por defecto al usar las funciones `read_*()` de `auk`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# importamos los datos de los listados (SED) \nchecklists <- read_sampling(f_sed) %>% \n  # seleccionamos solo los listados completos\n  filter(all_species_reported)\n# importamos los datos de observación (EBD)\nobservations <- read_ebd(f_ebd) %>% \n  # seleccionamos solo los listados completos\n  filter(all_species_reported)\n# uso de la función zero-fill para generar los datos de detección/no detección\nzf <- auk_zerofill(observations, checklists, collapse = TRUE)\nglimpse(zf)\n#> Rows: 80,577\n#> Columns: 41\n#> $ checklist_id              <chr> \"S114001497\", \"S118804608\", \"S116936975\", \"S…\n#> $ last_edited_date          <chr> \"2023-03-08 18:35:28.525811\", \"2023-03-08 18…\n#> $ country                   <chr> \"Chile\", \"Chile\", \"Chile\", \"Chile\", \"Chile\",…\n#> $ country_code              <chr> \"CL\", \"CL\", \"CL\", \"CL\", \"CL\", \"CL\", \"CL\", \"C…\n#> $ state                     <chr> \"Los Lagos\", \"Los Lagos\", \"Los Lagos\", \"Los …\n#> $ state_code                <chr> \"CL-LL\", \"CL-LL\", \"CL-LL\", \"CL-LL\", \"CL-LL\",…\n#> $ county                    <chr> \"Puerto Montt\", \"Curaco de Vélez\", \"Puerto V…\n#> $ county_code               <chr> \"CL-LL-OMO\", \"CL-LL-CUR\", \"CL-LL-OVA\", \"CL-L…\n#> $ iba_code                  <chr> NA, \"BIRDLIFE_26907\", NA, NA, NA, NA, NA, NA…\n#> $ bcr_code                  <int> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ usfws_code                <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ atlas_block               <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ locality                  <chr> \"piedra azul\", \"Curaco de Vélez--Humedales d…\n#> $ locality_id               <chr> \"L19884201\", \"L20235644\", \"L20552704\", \"L205…\n#> $ locality_type             <chr> \"P\", \"H\", \"P\", \"P\", \"H\", \"H\", \"H\", \"H\", \"H\",…\n#> $ latitude                  <dbl> -41.5, -42.4, -41.3, -42.9, -41.3, -41.3, -4…\n#> $ longitude                 <dbl> -72.8, -73.6, -72.9, -73.6, -73.1, -73.1, -7…\n#> $ observation_date          <date> 2019-08-15, 2019-01-24, 2019-02-16, 2019-02…\n#> $ time_observations_started <chr> \"08:00:00\", \"10:00:00\", \"17:08:00\", \"10:04:0…\n#> $ observer_id               <chr> \"obsr2818200\", \"obsr1166222\", \"obsr279749\", …\n#> $ observer_orcid_id         <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ sampling_event_identifier <chr> \"S114001497\", \"S118804608\", \"S116936975\", \"S…\n#> $ observation_type          <chr> \"Stationary\", \"Traveling\", \"Stationary\", \"St…\n#> $ protocol_name             <chr> \"Stationary\", \"Traveling\", \"Stationary\", \"St…\n#> $ protocol_code             <chr> \"P21\", \"P22\", \"P21\", \"P21\", \"P62\", \"P22\", \"P…\n#> $ project_names             <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ project_identifiers       <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ duration_minutes          <int> 480, 60, 5, 10, NA, 19, 22, 30, 23, 132, 2, …\n#> $ effort_distance_km        <dbl> NA, 1.000, NA, NA, NA, 0.308, 1.850, NA, 3.2…\n#> $ effort_area_ha            <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ number_observers          <int> 1, 1, 1, 1, 3, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,…\n#> $ all_species_reported      <lgl> TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TR…\n#> $ group_identifier          <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ checklist_comments        <chr> \"observada desde mi ventan en carretera aust…\n#> $ scientific_name           <chr> \"Scelorchilus rubecula\", \"Scelorchilus rubec…\n#> $ breeding_code             <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ breeding_category         <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ behavior_code             <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ age_sex                   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ observation_count         <chr> \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\",…\n#> $ species_observed          <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FA…\n```\n:::\n\n\n\n\nLa variable `observation_count` tiene conteos verdaderos así como también \"X\", estas indican que la especie fue detectada pero no se contó el número de individuos. `auk_zerofill()` agrega una nueva columna binaria, `species_observed`, indicando si la especie fue detectada o no.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nselect(zf, observation_count, species_observed) %>% \n  head(10) # observamos los primero 10 valores de las columnas con conteos y si se detectó la especie o no\n#> # A tibble: 10 × 2\n#>   observation_count species_observed\n#>   <chr>             <lgl>           \n#> 1 0                 FALSE           \n#> 2 0                 FALSE           \n#> 3 0                 FALSE           \n#> 4 0                 FALSE           \n#> 5 0                 FALSE           \n#> 6 0                 FALSE           \n#> # ℹ 4 more rows\n```\n:::\n\n\n\n\nConvirtamos las \"X\" en NAs y transformemos `observation_count` en una variable entera.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nzf$observation_count <- if_else(zf$observation_count == \"X\", \n                                NA_character_, zf$observation_count) %>% \n  as.integer()\nselect(zf, observation_count, species_observed) %>% \n  head(10)\n#> # A tibble: 10 × 2\n#>   observation_count species_observed\n#>               <int> <lgl>           \n#> 1                 0 FALSE           \n#> 2                 0 FALSE           \n#> 3                 0 FALSE           \n#> 4                 0 FALSE           \n#> 5                 0 FALSE           \n#> 6                 0 FALSE           \n#> # ℹ 4 more rows\n```\n:::\n\n\n\n\n## Filtrado de datos {#sec-ebird-filtering}\n\nAhora que tienes un conjunto de datos de detección/no detección, es probable que quieras hacer algo con él. Por ejemplo, puedes querer hacer un mapa, identificar áreas prioritarias para una especie o entrenar un modelo de distribución de especies. Independientemente de la aplicación específica, es probable que primero se requiera algún filtrado de los datos. Algunas de las formas en que puedes querer filtrar los datos de eBird incluyen:\n\n-   **Filtrado temporal**: filtrar los datos a un rango específico de años o a una época específica del año.\n-   **Filtrado espacial**: filtrar los datos para enfocarse en una región específica, por ejemplo, un área protegida.\n-   **Aumento de la precisión**: algunas listas de eBird son bastante largas en distancia o duración, lo que lleva a imprecisión espacial o temporal. Al eliminar listas más largas podemos aumentar la precisión espacial del conjunto de datos.\n-   **Reducción de la variación en el esfuerzo**: a diferencia de los estudios científicos estructurados, los datos se pueden enviar a eBird usando una variedad de protocolos y hay una variación significativa en el esfuerzo entre listas en el conjunto de datos de eBird. La variación en el protocolo y el esfuerzo conduce a variación en la detectabilidad (más esfuerzo generalmente conduce a mayor detectabilidad). Podemos elegir imponer más estructura en el conjunto de datos de eBird filtrando para reducir la variación en protocolo y esfuerzo.\n\nThe specific filtering you apply will depend on how you intend to use the eBird data. However, for the sake of this example, let's filter the eBird data to only traveling and stationary checklists from 2013-2022 that are less than 6 hours in duration and 10 km in length.\n\nEl filtrado específico que apliques dependerá de cómo pretendas usar los datos de eBird. Sin embargo, para este ejemplo, filtremos los datos de eBird solo a listas con desplazamiento y estacionarias de 2013-2025 que sean de menos de 6 horas de duración y 10 km de longitud.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nzf_filtered <- zf %>% \n  filter(year(observation_date) >= 2013, year(observation_date) <= 2025, # filtramos por años de interés\n         observation_type %in% c(\"Traveling\", \"Stationary\"), # filtramos por tipo de observación\n         duration_minutes < 6 * 60, # filtramos listas que tengan una duración menor a 6 horas\n         effort_distance_km < 10 | observation_type == \"Stationary\") # filtramos listas con distancias recorridas menores a 10 km\nnrow(zf)\n#> [1] 80577\nnrow(zf_filtered)\n#> [1] 75362\n```\n:::\n\n\n\n\nRedujimos el número de listas en 5,215 pero las listas restantes son de mayor calidad.\n\nFinalmente, muchas de las columnas en este data frame son innecesarias o redundantes, así que seleccionaremos solo las columnas que necesitamos.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nchecklists_zf <- zf_filtered %>% \n  select(checklist_id, \n         latitude, longitude,\n         observation_date, time_observations_started,\n         observation_type,\n         duration_minutes, effort_distance_km, number_observers,\n         observation_count, species_observed)\n```\n:::\n\n\n\n\n## Aplicaciones {#sec-ebird-applications}\n\n### Frecuencia de detección {#sec-ebird-applications-freq}\n\nLo más simple que podemos hacer con estas observaciones de eBird es estimar la frecuencia de detección del chucao en la región de Los Lagos. Esta es la proporción de listas de eBird en la región que detectaron la especie. `species_observed` es una columna binaria `TRUE/FALSE` que indica si se detectó la especie y R trata `TRUE` como 1 y `FALSE` como 0, por lo que podemos tomar el promedio de esta columna para obtener la frecuencia de detección.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmean(checklists_zf$species_observed)\n#> [1] 0.168\n```\n:::\n\n\n\n\nSo, Fork-tailed Flycatcher is fairly common within this region with 17% of checklists detecting the species. Detection frequency can be used to compare the prevalence of a species between regions or over time. For example, Fork-tailed Flycatcher is migratory, so let's look at how detection frequency changes over the months of the year.\n\nEntonces, el chucao es bastante común dentro de esta región, con un 0.17% de las listas detectando la especie. La frecuencia de detección se puede usar para comparar la prevalencia de una especie entre regiones o a lo largo del tiempo. Veamos cómo cambia la frecuencia de detección a lo largo de los meses del año.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmonthly_detection <- checklists_zf %>% \n  mutate(month = month(observation_date)) %>% \n  group_by(month) %>% \n  summarize(detection_frequency = mean(species_observed))\n\n# plot monthly detection frequency\nggplot(monthly_detection) +\n  aes(x = month, y = detection_frequency) +\n  geom_line() +\n  geom_point() +\n  scale_x_continuous(breaks = 1:12) +\n  scale_y_continuous(labels = scales::percent) +\n  labs(x = \"Mes del año\",\n       y = \"Frecuencia de detección\",\n       title = \"Frecuencia de detección mensual del chucao\",\n       subtitle = \"Los Lagos, Chile\")\n```\n\n::: {.cell-output-display}\n![](ebird_files/figure-html/ebird-applications-freq-monthly-1.png){fig-align='center' width=\\textwidth}\n:::\n:::\n\n\n\n\nBased on this chart, Fork-tailed Flycatcher appears to arrive in Rio Grande do Sul in September and depart in February.\n\nBasándose en este gráfico, el chucao parece ser más detectado entre diciembre y marzo.\n\n::: {.callout-caution icon=\"false\"}\n## Ejercicio\n\nUsa una técnica similar para calcular y graficar el número mensual de listas de eBird en Los Lagos. ¿Hay diferencias entre los meses? Si es así, ¿qué nos dice esto sobre el uso del número de detecciones a partir de datos de solo presencia como una medida de prevalencia?\n:::\n\n::: {.callout-note icon=\"false\" collapse=\"true\"}\n## Solución\n\nExiste una variabilidad en el envío de listas por mes, con menos del doble de listas en enero comparado con junio. Si examináramos el número mensual de detecciones utilizando únicamente datos de presencia, esperaríamos más detecciones en los meses con mayor cantidad de listas, incluso si la prevalencia del chucao permanece constante.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmonthly_checklists <- count(checklists_zf, month = month(observation_date))\n\n# plot monthly number of checklists\nggplot(monthly_checklists) +\n  aes(x = month, y = n) +\n  geom_line() +\n  geom_point() +\n  scale_x_continuous(breaks = 1:12) +\n  scale_y_continuous(limits = c(0, NA), labels = scales::comma) +\n  labs(x = \"Mes del año\",\n       y = \"Número de listados en eBird\",\n       title = \"Listados mensuales subidos a eBird en Los Lagos\")\n```\n\n::: {.cell-output-display}\n![](ebird_files/figure-html/ebird-applications-freq-sol-1.png){fig-align='center' width=\\textwidth}\n:::\n:::\n\n\n\n:::\n\n### Conversión a formato espacial {#sec-ebird-applications-spatial}\n\nMuchas aplicaciones de datos de eBird requieren convertir los datos en un formato explícitamente espacial, por ejemplo, para hacer un mapa o filtrar las observaciones solo a aquellas dentro de un polígono para un área protegida. El paquete de R [`sf`](https://r-spatial.github.io/sf/) se puede usar para representar puntos, líneas y polígonos espaciales en R. Podemos convertir el data frame de las listas a un objeto `sf` usando la latitud y longitud.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nchecklists_sf <- st_as_sf(checklists_zf, coords = c(\"longitude\", \"latitude\"),\n                          # 4326 is the code for an unprojected lon/lat\n                          # coordiante reference system\n                          crs = 4326)\nprint(checklists_sf)\n#> Simple feature collection with 75362 features and 9 fields\n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: -75.3 ymin: -43.8 xmax: -71.7 ymax: -40.2\n#> Geodetic CRS:  WGS 84\n#> # A tibble: 75,362 × 10\n#>   checklist_id observation_date time_observations_started observation_type\n#> * <chr>        <date>           <chr>                     <chr>           \n#> 1 S118804608   2019-01-24       10:00:00                  Traveling       \n#> 2 S116936975   2019-02-16       17:08:00                  Stationary      \n#> 3 S116936842   2019-02-13       10:04:00                  Stationary      \n#> 4 S59435786    2019-09-01       15:09:00                  Traveling       \n#> 5 S58442786    2019-07-25       13:47:00                  Traveling       \n#> 6 S62449405    2019-12-18       16:40:00                  Stationary      \n#> # ℹ 75,356 more rows\n#> # ℹ 6 more variables: duration_minutes <int>, effort_distance_km <dbl>,\n#> #   number_observers <int>, observation_count <int>, species_observed <lgl>,\n#> #   geometry <POINT [°]>\n```\n:::\n\n\n\n\nImagina que solo estamos interesados en observaciones dentro de 50 km de Dalcahue, Chile. Podemos usar `sf` para generar un círculo de radio 50 km centrado en Dalcahue, y luego filtrar las observaciones que caen dentro del círculo.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Asignamos las coordenadas de nuestro punto de interés, en este caso las coordenadas de Dalcahue\ndalcahue_point <- st_sfc(st_point(c(-73.6473, -42.3796)), crs = 4326)\n\n# Generamos un circulo a partir del punto con un buffer de 50 km\ndalcahue_circle <- st_buffer(dalcahue_point, dist = 50000)\n\n# Filtramos los registros que caen dentro del área\nchecklists_dalcahue <- checklists_sf[dalcahue_circle, ]\n```\n:::\n\n\n\n\nAhora podríamos, por ejemplo, calcular la frecuencia de detección en el área alrededor de Dalcahue.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmean(checklists_dalcahue$species_observed)\n#> [1] 0.205\n```\n:::\n\n\n\n\nFinalmente, en muchos casos, puede ser más conveniente trabajar con datos de eBird fuera de R en un SIG como [QGIS](https://qgis.org/en/site/), un programa gratuito y de código abierto. Podemos exportar las observaciones de chucao a un GeoPackage usando `sf`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwrite_sf(checklists_sf, \"data/chutap1-ebird_CL-LL.gpkg\",\n         layer = \"chucao_observations\")\n```\n:::\n\n\n\n\n::: callout-tip\n## Tip\n\nEl [GeoPackage](https://www.geopackage.org/) es una alternativa moderna y de código abierto en formato shapefile para almacenar datos espaciales. Los GeoPackages evitan muchos de los problemas y limitaciones asociados con los shapefiles, y son mucho más eficientes que los shapefiles. La documentación en línea de ArcGIS proporciona [instrucciones sobre cómo abrir un GeoPackage en ArcGIS](https://desktop.arcgis.com/en/arcmap/latest/manage-data/databases/connect-sqlite.htm).\n:::\n\n### Mapeo {#sec-ebird-applications-mapping}\n\nAhora que tenemos los datos en formato espacial, podemos producir un mapa de los datos de detección/no detección del chucao. Para mapas complejos y altamente personalizados, recomendamos usar un SIG como QGIS que está específicamente diseñado para cartografía. Sin embargo, es posible hacer un mapa rápido y simple en R.\n\nComenzaremos cargando polígonos que definen las fronteras de países y estados, que proporcionarán información contextual para nuestro mapa. Estos polígonos provienen de [Natural Earth](https://www.naturalearthdata.com/downloads/), una excelente fuente de datos espaciales globales sin atribución. El paquete de R `rnaturaleart` proporciona acceso a datos de Natural Earth dentro de R; sin embargo, por conveniencia hemos preparado las capas necesarias la clase pasada y además están para descarga en el archivo `data/gis-data.gpkg` incluido en los archivos para el curso. Proyectaremos todo a una proyección de área igual centrada en la región de Los Lagos, Chile.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncrs <- st_crs(\"+proj=laea +lat_0=-41 +lon_0=-72.5\")\n\n# Polígonos de Natural Earth\nne_land <- read_sf(\"data/gis-data-chile.gpkg\", \"chile_territorio\") %>% \n  st_transform(crs = crs)\nne_country_lines <- read_sf(\"data/gis-data-chile.gpkg\", \"chile_fronteras\") %>% \n  st_transform(crs = crs)\nrgds_boundary <- read_sf(\"data/gis-data-chile.gpkg\", \"chile_regiones\") %>% \n  filter(region == \"Los Lagos\") %>% \n  st_transform(crs = crs)\n\n# transform ebird data to equal area projection\nchecklists_proj <- st_transform(checklists_sf, crs = crs)\n```\n:::\n\n\n\n\nAhora podemos hacer un mapa de observaciones de chucao en Los Lagos. Construimos el mapa en capas, primero creando un mapa base con los polígonos de Natural Earth, luego graficando los datos de detección y no detección de eBird encima. Al construir un mapa en capas como este, a menudo es útil primero graficar una versión en blanco del conjunto de datos principal que pretendes mapear para definir la extensión espacial del mapa, luego superponer todo lo demás, finalizando con graficar los datos una segunda vez para que aparezcan como la capa superior.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Configuramos los márgenes del gráfico (reducidos para maximizar espacio del mapa)\npar(mar = c(0.25, 0.25, 2, 0.25))\n\n# Cresmos un gráfico en blanco que define la extensión espacial del mapa. Esto establece los límites del área que queremos mostrar\nplot(st_geometry(checklists_proj), col = NA)\n\n# Agregamos las capas de contexto geográfico (de fondo hacia adelante)\n\n# 1. Territorio de Chile (gris claro de fondo)\nplot(ne_land, \n     col = \"#eeeeee\",      # color gris claro para el territorio\n     border = \"#888888\",   # borde gris oscuro\n     lwd = 0.5,           # grosor de línea delgado\n     add = TRUE)          # agregar a gráfico existente\n\n# 2. Región de Los Lagos (gris medio para destacarla)\nplot(rgds_boundary, \n     col = \"#cccccc\",     # color gris medio\n     border = NA,         # sin borde \n     add = TRUE)         # agregar a gráfico existente\n\n# 3. Fronteras internacionales (líneas negras)\nplot(ne_country_lines, \n     col = \"#000000\",     # color negro para  fronteras\n     lwd = 1.5,          # línea más gruesa\n     add = TRUE)\n\n# 4. observaciones de eBird\n# Listas donde NO se detectó Chucao (puntos grises pequeños)\nplot(filter(checklists_proj, !species_observed),\n     pch = 19,                          # punto sólido\n     cex = 0.2,                         # tamaño pequeño\n     col = alpha(\"#555555\", 0.5),       # gris semi-transparente\n     add = TRUE)\n#> Warning in plot.sf(filter(checklists_proj, !species_observed), pch = 19, :\n#> ignoring all but the first attribute\n\n# Listas donde SÍ se detectó Chucao (puntos verdes más grandes)\nplot(filter(checklists_proj, species_observed),\n     pch = 19,                          # punto sólido\n     cex = 0.3,                         # tamaño ligeramente mayor\n     col = alpha(\"#4daf4a\", 1),         # verde sólido\n     add = TRUE)\n#> Warning in plot.sf(filter(checklists_proj, species_observed), pch = 19, :\n#> ignoring all but the first attribute\n\n# Agregamos la leyenda\nlegend(\"bottomleft\",                   # posición en esquina inferior izquierda\n       bty = \"n\",                       # sin caja alrededor\n       col = c(\"#555555\", \"#4daf4a\"),   # colores: gris y verde\n       legend = c(\"Listas de eBird\",    # texto de leyenda\n                  \"Avistamientos de Chucao\"),\n       pch = 19)                        # símbolo: punto sólido\n\n# Agregsmos el borde y título\nbox()                                   # marco alrededor del mapa\ntitle(\"Observaciones de Chucao en eBird (2013-2025)\\nRegión de Los Lagos, Chile\")\n```\n\n::: {.cell-output-display}\n![](ebird_files/figure-html/ebird-applications-mapping-map-1.png){fig-align='center' width=\\textwidth}\n:::\n:::\n\n\n\n\n## Código para extraer datos del eBird Basic Dataset (EBD) para sitios prioritarios\n\nEste código nos permitirá extraer datos del EBD y resumir la información registrada para un área geográfica de interés utilizando un polígono.\n\nPara correr este código se requieren de tres archivos.\n\n1.  El eBird Basic Dasaset (EBD) de la región de Los Lagos (`ebd_CL-LL_smp_relAug-2025.txt`).\n\n2.  El polígono del área de interés, que en este caso es un área que cubre parte del río Petrohue, Ralún, Chile (`ralun.kml`). El paquete \"sf\" utilizado acepta archivos en formato .shp o .kml\n\n3.  **Opcional** Un archivo con nombres locales y categorías de conservación de las especies. En este caso, un archivo con el listado de aves de Chile y su categoría de conservación (`lista aves de chile.csv`).\n\nPartimos cargando los paquetes que necesitaremos en esta parte del curso\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(auk)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(lubridate)\nlibrary(sf)\nlibrary(tibble)\nlibrary(tidyr)\nlibrary(readr)\n```\n:::\n\n\n\n\nLuego, importamos los archivos que necesitaremos para trabajar. El set de datos con los que trabajaremos (EBD), en este caso son todos los registros que existen en la región de Los Lagos, el polígono del área de interés y una planilla que contiene información sobre las aves, como sus nombre comunes en español, su estatus en el país y sus categorías de conservación.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# importamos los datos de observaciones\nf_ebd <- \"data/ebd_CL-LL_smp_relAug-2025.txt\" \nobs <- read_ebd(f_ebd)\n\n# en la columna de conteos convertimos los \"X\" a NA y transformamos el formato a números enteros\nobs$observation_count <- if_else(obs$observation_count == \"X\", NA_character_, \n                                 obs$observation_count) %>% \n  as.integer()\n\n# cargamos el archivo del polígono, puede ser .shp o .kml \npoly <- read_sf(\"data/ralun.kml\") #insertar nombre de archivo propio\n\n# cargamos la planilla con información de las especies, como su categoría de conservacion\ncat <- read.csv2(\"data/lista aves de chile.csv\")\n# seleccionamos las columnas que son de nuestro interés\ncat <- cat %>% select(nombre.científico..Clements., nombre.común, clasificación.IUCN, clasificación.RCE, Chile.total)\n```\n:::\n\n\n\n\nUna vez cargados los archivos, filtraremos la base de datos de las observaciones de acuerdo a criterios que uno establezca relacionados al esfuerzo de muestreo, como por ejemplo el tipo de observación realizado, la distancia recorrida, la duración del muestreo o la cantidad de observadores.\n\nPara este ejemplo, filtraremos las listas que presenten distancias recorridas menores a 10 km y menos de seis horas de observación. Además, filtraremos las columnas de nuestro interés y modificaremos las categorías de códigos reproductivos para facilitar la visualización.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nobs_fil <- obs %>%\n  filter(protocol_name %in% c(\"Traveling\", \"Stationary\"), # filtramos listas hechas con desplazamiento y estacionarias\n         duration_minutes < 6 * 60, # que tengan una duración menor a 6 horas\n         effort_distance_km < 10 | protocol_name == \"Stationary\") # con distancias recorridas menores a 10 km\n\n# seleccionamos solo las columnas necesarias para reducir tamaño del dataframe\nobs_lim <- obs_fil %>%\n  select(sampling_event_identifier,\n         taxonomic_order,\n         common_name,\n         scientific_name,\n         observation_count,\n         breeding_category,\n         latitude,\n         longitude,\n         observation_date)\n\n# cambiamos la jerarquía de categorias de códigos reproductivos a una jerarquía numérica\nobs_lim <- obs_lim %>%\n  mutate(breeding_category = recode(breeding_category,'C1'=1,'C2'=2,'C3'=3,'C4'=4),\n         breeding_category = as.integer(as.character(breeding_category)))\n```\n:::\n\n\n\n\nCon nuestros archivos preparados, trabajaremos ahora en la sección espacial del código. Partiremos transformando el objeto que contiene las observaciones (`obs_lim`) a un formato shapefile. Dejaremos ambos objetos con los que trabajaremos (`ebd_sf` y `poly`) con el mismo crs. Opcionalmente dejamos explicita la opción de incorporar un buffer al polígono , por si quisiéramos considerar también listados que quedasen justo fuera del polígono, por haber terminado o empezado fuera de este. Finalmente identificaremos y filtraremos los listados que caen dentro del polígono del área de interés.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# transformamos el objeto con las observaciones a formato shape file y le asignamos crs\nebd_sf <- obs_lim %>% \n  select(longitude, latitude) %>% \n  st_as_sf(coords = c(\"longitude\", \"latitude\"), crs = 4326)\n\n# transformamos el polígono de nuestra área de interés para tener el mismo crs que el archivo de las observaciones\npoly_ll <- st_transform(poly, crs = st_crs(ebd_sf))\n\n# opcionalmente podemos incluir un buffer alrededor del polígono para incluir datos de listas que pudieran haber empezado o terminado fuera del polígono\npoly_ll_buffer <- st_buffer(poly_ll, dist = 1000) # en este caso agregamos un buffer de 1km\n\n# identificamos los puntos (listas) que caen dentro del polígono\nin_poly <- st_within(ebd_sf, poly_ll_buffer, sparse = FALSE)\n\n# filtramos los datos que caen dentro del polígono\nebd_in_poly <- obs_lim[in_poly[, 1], ]\n```\n:::\n\n\n\n\nFinamente, tenemos la base de datos registrados en el área de interés. En esta última parte generaremos una tabla resumen que presente las observaciones del área de manera consisa.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# realizamos una lista de especies registradas, con nombre común, científico y orden taxonómico\nespecie <-   ebd_in_poly %>% \n  distinct(common_name,scientific_name,taxonomic_order) %>% \n  arrange(common_name) %>%\n  distinct(common_name, .keep_all = TRUE)\n\n# generamos una lista de especies registradas durante el último año y sus máximos para ese año\nregistro_último_año <-  ebd_in_poly %>% \n  filter(year(observation_date) == year(max(observation_date))) %>% \n  group_by(common_name) %>% \n  arrange(desc(observation_count)) %>%  # Ordenar en orden descendente de conteo\n  summarise(conteo_max_último_año = max(observation_count, na.rm=TRUE),checklist.x = first(sampling_event_identifier),\n            conteo_max_último_año = replace(conteo_max_último_año, conteo_max_último_año == -Inf, 0)) %>%\n  mutate(registro_último_año = TRUE)\n#> Warning: There were 4 warnings in `summarise()`.\n#> The first warning was:\n#> ℹ In argument: `conteo_max_último_año = max(observation_count, na.rm = TRUE)`.\n#> ℹ In group 5: `common_name = \"Black-crowned Night Heron\"`.\n#> Caused by warning in `max()`:\n#> ! no non-missing arguments to max; returning -Inf\n#> ℹ Run `dplyr::last_dplyr_warnings()` to see the 3 remaining warnings.\n\n# resumimos el conteo máximo histórico para cada especie registrada en el polígono\nconteo_max_h <- ebd_in_poly %>% \n  group_by(common_name) %>%\n  arrange(desc(observation_count)) %>%\n  slice(1) %>%  # Tomar solo la primera fila (máximo conteo)\n  summarise(conteo_max_h = max(observation_count, na.rm=TRUE),\n            año_max_h = max(year(observation_date)), \n            checklist.y = first(sampling_event_identifier))\n#> Warning: There were 3 warnings in `summarise()`.\n#> The first warning was:\n#> ℹ In argument: `conteo_max_h = max(observation_count, na.rm = TRUE)`.\n#> ℹ In group 8: `common_name = \"Black-chested Buzzard-Eagle\"`.\n#> Caused by warning in `max()`:\n#> ! no non-missing arguments to max; returning -Inf\n#> ℹ Run `dplyr::last_dplyr_warnings()` to see the 2 remaining warnings.\n\n# calculamos un promedio de conteo en los registros de los últimos 5 años para cada especie\nprom_conteo_5_años <- ebd_in_poly %>% \n  filter(year(observation_date) >= (year(max(observation_date)) - 4)) %>% \n  group_by(common_name) %>% \n  summarise(prom_conteos_5_años = round(mean(observation_count, na.rm=TRUE)))\n\n# asignamos el código reproductivo más alto registrado para cada especie en el polígono\ncod_rep <- ebd_in_poly %>% \n  group_by(common_name) %>% \n  summarise(cod_rep = max(breeding_category, na.rm = TRUE),\n            cod_rep = replace(cod_rep, cod_rep == -Inf, 0))\n#> Warning: There were 59 warnings in `summarise()`.\n#> The first warning was:\n#> ℹ In argument: `cod_rep = max(breeding_category, na.rm = TRUE)`.\n#> ℹ In group 1: `common_name = \"Ashy-headed Goose\"`.\n#> Caused by warning in `max()`:\n#> ! no non-missing arguments to max; returning -Inf\n#> ℹ Run `dplyr::last_dplyr_warnings()` to see the 58 remaining warnings.\n\n# creamos la tabla resumen                                                  \ntabla_datos <- left_join(especie,registro_último_año, by = \"common_name\") %>%\n  left_join(.,conteo_max_h, by = \"common_name\") %>%\n  left_join(.,prom_conteo_5_años, by = \"common_name\") %>%\n  left_join(.,cod_rep, by = \"common_name\") %>%\n  left_join(., cat, by = c(\"scientific_name\" = \"nombre.científico..Clements.\")) %>% \n  group_by(common_name) %>%\n  select(\"nombre.común\",\"common_name\",\"scientific_name\",\"registro_último_año\",\"conteo_max_último_año\",\"checklist.x\",\"conteo_max_h\",\"año_max_h\",\"checklist.y\",\"prom_conteos_5_años\",\"cod_rep\",\"clasificación.RCE\",\"clasificación.IUCN\",\"taxonomic_order\",\"Chile.total\")\n\n\n# ordenamos la tabla según orden taxonómico, reemplazamos los NAs y los números infinitos por 0\ntabla_datos <- tabla_datos %>%\n  arrange(taxonomic_order) %>% # ordenamos la tabla de acuerdo al orden taxonómico\n  mutate_all(function(x) ifelse(is.infinite(x), 0, x)) %>% # reemplazamos los numeros infinitos por 0, cuando todos los registros de la especie fueron ingresados como 'X' \n  select(-taxonomic_order)%>% # quitamos la columna de número taxonómico\n  rename(nombre.inglés = common_name, nombre.cientifico = scientific_name) # renombramos las columnas para que tengan el mismo idioma y formato \n\n# remplazamos los NA con 0 en columnas numéricas de la tabla resumen\ntabla_datos <- tabla_datos %>%\n  mutate(conteo_max_último_año = ifelse(is.na(conteo_max_último_año), 0, conteo_max_último_año),\n         prom_conteos_5_años = ifelse(is.na(prom_conteos_5_años), 0, prom_conteos_5_años))\n\n# remplazamos con NA los 0 en las columna de texto\ntabla_datos$registro_último_año <- replace(tabla_datos$registro_último_año, is.na(tabla_datos$registro_último_año),FALSE)\n\n# exportamos la tabla resumen como archivo .csv\nwrite.csv(tabla_datos, \"datos_eBird_ralun.csv\")\n```\n:::\n\n\n\n\nComo herramienta adicional, podemos graficar la ubicación de los listados extraidos. esto nos permite revisar la distribución de estos en el área de interés, como también corroborar si el uso del buffer se justifica o si modificamos el tamaño de este.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npar(mar = c(0, 0, 0, 0))\nplot(poly %>% st_geometry(), col = \"gray\", border = NA)\nplot(ebd_sf[in_poly[, 1], ], \n     col = \"black\", pch = 19, cex = 0.5, \n     add = TRUE)\nlegend(\"top\", \n       legend = \"Ubicación datos eBird dentro del poligono\",\n       pch = 19,\n       bty = \"n\")\n```\n\n::: {.cell-output-display}\n![](ebird_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=\\textwidth}\n:::\n:::\n",
    "supporting": [
      "ebird_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}