---
title: "Abundancia relativa"
author: "ROC"
format: html
---

# Abundancia relativa {#sec-abundance}

El capítulo anterior se enfocó en modelar la tasa de encuentro, la probabilidad de detectar una especie en una lista eBird estándar. Sin embargo, además de registrar las especies observadas, la mayoría de los usuarios de eBird también especifican cuántos individuos de cada especie observaron. Por lo tanto, en este capítulo, aprovecharemos estos conteos para modelar una medida relativa de la abundancia de las especies.

Para motivar este capítulo, nos centraremos en el objetivo específico de estimar un mapa de abundancia relativa. Este tipo de mapa nos ayudará a identificar áreas con mayor o menor abundancia. La métrica que utilizaremos para estimar la abundancia es el número esperado de individuos observados en una lista de verificación estandarizada de eBird. Al igual que el modelo de tasa de encuentro, el modelo de abundancia que presentamos en esta sección tiene en cuenta la variación en las tasas de detección, pero no estima directamente la probabilidad absoluta de detección. Por esta razón, las estimaciones de abundancia que realizamos solo pueden interpretarse como una medida de abundancia relativa; un índice del *número* de individuos de la especie presentes en el área de búsqueda. Para ajustarnos a la terminología común en la literatura, nos referimos a esto como una estimación de la abundancia *relativa*.

El modelo de abundancia relativa que presentamos aquí es similar al modelo de tasa de encuentros del Capítulo anterior y constituye una extensión natural del mismo. En particular, utilizamos un modelo de dos etapas con umbral, siguiendo a Keyser et al. [-@keyserSnowCoverDynamics2023]. En la primera etapa, estimamos la tasa de encuentros utilizando el mismo método que en el Capítulo anterior. En la segunda etapa, estimamos el número esperado de individuos en las listas de eBird donde se detectó la especie. Finalmente, multiplicamos la tasa de encuentros por la mediana del número de individuos para obtener una estimación de la abundancia relativa. Utilizamos random forest en ambas etapas del modelo de umbrales.

## Preparación de datos {#sec-encounter-data}

Comencemos cargando los paquetes y datos necesarios. Si has completado los capítulos anteriores, ya deberías tener todos los datos necesarios para este capítulo. Sin embargo, es posible que quieras [descargar el paquete de datos](https://github.com/ebird/ebird-best-practices/raw/main/data-raw/ebird-best-practices-data.zip), y descomprímelo en el directorio de tu proyecto, para asegurarte de que estás trabajando exactamente con los mismos datos que se utilizaron en la creación de esta guía.

```{r}
#| label: encounter-data-load
library(dplyr)
library(ebirdst)
library(fields)
library(ggplot2)
library(gridExtra)
library(lubridate)
library(mccf1)
library(ranger)
library(readr)
library(scam)
library(sf)
library(terra)
library(tidyr)

# definir número aleatorio semilla para reproducibilidad
set.seed(1)

# variables ambientales: cobertura de suelo y altitud
env_vars <- read_csv("data/environmental-variables_checklists_jun_us-ga.csv")

# datos de eBird rellenados con ceros combinados con datos ambientales
checklists <- read_csv("data/checklists-zf_woothr_jun_us-ga.csv") |> 
  inner_join(env_vars, by = "checklist_id")

# cuadrícula de predicción
pred_grid <- read_csv("data/environmental-variables_prediction-grid_us-ga.csv")
# plantilla ráster para la cuadrícula
r <- rast("data/prediction-grid_us-ga.tif")
# obtener el sistema de referencia de coordenadas para la cuadrícula de predicción
crs <- st_crs(r)

# cargar datos GIS para la creación de mapas
study_region <- read_sf("data/gis-data.gpkg", "ne_states") |> 
  filter(state_code == "US-GA") |> 
  st_transform(crs = crs) |> 
  st_geometry()
ne_land <- read_sf("data/gis-data.gpkg", "ne_land") |> 
  st_transform(crs = crs) |> 
  st_geometry()
ne_country_lines <- read_sf("data/gis-data.gpkg", "ne_country_lines") |> 
  st_transform(crs = crs) |> 
  st_geometry()
ne_state_lines <- read_sf("data/gis-data.gpkg", "ne_state_lines") |> 
  st_transform(crs = crs) |> 
  st_geometry()
```

A continuación, siguiendo el enfoque descrito en el capítulo anterior, realizaremos una ronda de submuestreo espaciotemporal en los datos para reducir el sesgo.

```{r}
#| label: encounter-data-sss
# muestrear de una lista por cada cuadrícula de 3 km x 3 km x 1 semana para cada año.
# muestreo de detección/no detección de forma independiente
checklists_ss <- grid_sample_stratified(checklists,
                                        obs_column = "species_observed",
                                        sample_by = "type")
```

Finalmente, eliminaremos el 20% de las listas de verificación reservadas para pruebas y seleccionaremos únicamente las columnas que pretendemos utilizar como predictores para entrenar los modelos.

```{r}
#| label: encounter-data-train
checklists_train <- checklists_ss |> 
  filter(type == "train") |> 
  # seleccioanr solo las columnas a usar en el modelo
  select(species_observed, observation_count,
         year, day_of_year, hours_of_day,
         effort_hours, effort_distance_km, effort_speed_kmph,
         number_observers, 
         starts_with("pland_"),
         starts_with("ed_"),
         starts_with("elevation_"))
```

## Modelo de obstáculos {#sec-abundance-hurdle}

Para este modelo de dos pasos con obstáculos, comenzaremos entrenando el mismo modelo de tasa de encuentros que en el capítulo anterior. Luego, seleccionaremos un subconjunto de la lista de verificación de eBird que incluya solo aquellas especies detectadas o cuya presencia fue predicha por el modelo de tasa de encuentros. Utilizaremos este subconjunto de datos para entrenar un segundo modelo de random forest para el conteo esperado. Finalmente, combinaremos los resultados de ambos pasos para obtener estimaciones de abundancia relativa.

### Paso 1: Tasa de encuentro {#sec-abundance-hurdle-er}

En el capítulo anterior explicamos el modelo de tasa de encuentros calibrado. Aquí repetimos el proceso de modelado de la tasa de encuentros de forma concisa.

```{r}
#| label: abundance-hurdle-er
#| results: "hold"
# calcular frecuencia de detección para el random forest 
detection_freq <- mean(checklists_train$species_observed)

# entrenar un modelo de random forest para la tasa de encuentros
train_er <- select(checklists_train, -observation_count)
er_model <- ranger(formula =  as.factor(species_observed) ~ ., 
                   data = train_er,
                   importance = "impurity",
                   probability = TRUE,
                   replace = TRUE,
                   sample.fraction = c(detection_freq, detection_freq))

# seleccionar el umbral de ocurrencia de optimización mcc-F1
obs_pred <- data.frame(obs = as.integer(train_er$species_observed), 
                       pred = er_model$predictions[, 2])
mcc_f1 <- mccf1(response = obs_pred$obs, predictor = obs_pred$pred)
mcc_f1_summary <- summary(mcc_f1)
threshold <- mcc_f1_summary$best_threshold[1]

# modelo de calibración
calibration_model <- scam(obs ~ s(pred, k = 6, bs = "mpi"), 
                          gamma = 2,
                          data = obs_pred)
```

### Paso 2: Contar {#sec-abundance-hurdle-count}

En el segundo paso, entrenamos un modelo de random forest para estimar el número esperado de individuos en las listas de eBird donde la especie fue detectada o se predijo su detección mediante el modelo de tasa de encuentros. Para ello, comenzaremos seleccionando únicamente estas listas de eBird. Además, eliminaremos cualquier observación en la que el observador reportó la presencia del zorzal de Swainson, pero no indicó el número de individuos (codificado como "X" en la base de datos de eBird, pero convertido a `NA` en nuestro conjunto de datos).

```{r}
#| label: abundance-hurdle-count-filter
# adjuntar la tasa de encuentro prevista basada en muestras fuera de la bolsa.
train_count <- checklists_train
train_count$pred_er <- er_model$predictions[, 2]
# muestrear para solo detecciones observadas o predichas
train_count <- train_count |> 
  filter(!is.na(observation_count),
         observation_count > 0 | pred_er > threshold) |> 
  select(-species_observed, -pred_er)
```

Hemos observado que incluir la tasa de encuentros estimada como predictor en el modelo de conteo mejora el rendimiento predictivo. Por lo tanto, teniendo esto en cuenta, predecimos la tasa de encuentros para el conjunto de datos de entrenamiento y la añadimos como una columna adicional.

```{r}
#| label: abundance-hurdle-count-preder
predicted_er <- predict(er_model, data = train_count, type = "response")
predicted_er <- predicted_er$predictions[, 2]
train_count$predicted_er <- predicted_er
```

Finalmente, entrenamos un modelo de random forest para estimar el recuento. Este modelo es superficialmente muy similar al modelo de random forest para la tasa de encuentros; sin embargo, para el recuento utilizamos un random forest de regresión, mientras que para la tasa de encuentros utilizamos un random forest de clasificación balanceada.

```{r}
#| label: abundance-hurdle-count-train
count_model <- ranger(formula = observation_count ~ .,
                      data = train_count,
                      importance = "impurity",
                      replace = TRUE)
```

### Evaluación {#sec-abundance-assess}

En Evaluación del capítulo anterior calculamos un conjunto de métricas de rendimiento predictivo para el modelo de tasa de encuentros. Estas métricas también deben considerarse al modelar la abundancia relativa; sin embargo, no duplicaremos el cálculo de estas métricas aquí. En su lugar, calcularemos el [coeficiente de correlación de rangos de Spearman](https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient)tanto para el recuento como para la abundancia relativa, y el [coeficiente de correlación de Pearson](https://en.wikipedia.org/wiki/Pearson_correlation_coefficient) para el logaritmo del recuento y la abundancia relativa. Comenzaremos estimando la tasa de encuentros, el recuento y la abundancia relativa para el conjunto de datos de prueba muestreado en cuadrícula espaciotemporal.

```{r}
#| label: abundance-assess-estimate
# obtener el conjunto de prueba reservado para el entrenamiento.
checklists_test <- filter(checklists_ss, type == "test") |> 
  mutate(species_observed = as.integer(species_observed)) |> 
  filter(!is.na(observation_count))

# estimar tasa de encuentro para los datos de prueba
pred_er <- predict(er_model, data = checklists_test, type = "response")
# extraer probabilidad de detección
pred_er <- pred_er$predictions[, 2]
# convertir a binario usando el umbral
pred_binary <- as.integer(pred_er > threshold)
# calibrar
pred_calibrated <- predict(calibration_model, 
                           newdata = data.frame(pred = pred_er), 
                           type = "response") |> 
  as.numeric()
# restringir probabilidades a 0-1
pred_calibrated[pred_calibrated < 0] <- 0
pred_calibrated[pred_calibrated > 1] <- 1

# añadir la tasa de encuentros requerida para las estimaciones de conteo
checklists_test$predicted_er <- pred_er
# estimar conteos
pred_count <- predict(count_model, data = checklists_test, type = "response")
pred_count <- pred_count$predictions

# la abundancia relativa es el producto de la tasa de encuentro y el conteo
pred_abundance <- pred_calibrated * pred_count

# combinar observaciones y estimados
obs_pred_test <- data.frame(
  id = seq_along(pred_abundance),
  # detección/no detección real
  obs_detected = as.integer(checklists_test$species_observed),
  obs_count = checklists_test$observation_count,
  # estimaciones del modelo
  pred_binary = pred_binary,
  pred_er = pred_calibrated,
  pred_count = pred_count,
  pred_abundance = pred_abundance
)
```

Las métricas de conteo miden el rendimiento *dentro del rango*, lo que significa que comparamos el conteo observado con el conteo estimado *solo para aquellas listas donde el modelo predice la presencia de la especie*. La abundancia relativa considera tanto la tasa de encuentro como el conteo, por lo que el rendimiento predictivo de la abundancia se basa en todas las listas de verificación.

```{r}
#| label: abundance-assess-count
# muestrear solo aquellas listas donde ocurrió detección
detections_test <- filter(obs_pred_test, obs_detected > 0)

# métricas de recuento, basadas únicamente en listas donde se detectó
count_spearman <- cor(detections_test$pred_count, 
                      detections_test$obs_count,
                      method = "spearman")
log_count_pearson <- cor(log(detections_test$pred_count + 1),
                         log(detections_test$obs_count + 1),
                         method = "pearson")

# métricas de abundancia
abundance_spearman <- cor(detections_test$pred_abundance, 
                          detections_test$obs_count,
                          method = "spearman")
log_abundance_pearson <- cor(log(detections_test$pred_abundance + 1),
                             log(detections_test$obs_count + 1),
                             method = "pearson")

# combinar ppms
ppms <- data.frame(
  count_spearman = count_spearman,
  log_count_pearson = log_count_pearson,
  abundance_spearman = abundance_spearman,
  log_abundance_pearson = log_abundance_pearson
)
knitr::kable(pivot_longer(ppms, everything()), digits = 3)
```

Las correlaciones de Spearman nos informan sobre la capacidad del modelo para estimar el orden de frecuencia y la abundancia relativa, aspectos en los que estos modelos suelen tener un mejor desempeño. Las correlaciones de Pearson nos brindan información sobre la capacidad del modelo para estimar frecuencias absolutas en escala logarítmica, una tarea que suele ser más difícil con los datos de eBird, especialmente para especies congregacionales que a menudo presentan frecuencias elevadas. Al igual que con las métricas de rendimiento de la tasa de encuentros, estas son útiles para comparar la calidad del modelo entre especies, regiones y estaciones.

## Predicción {#sec-abundance-predict}

Tal como hicimos con la función predict para la tasa de avistamientos, podemos estimar la abundancia relativa en nuestra cuadrícula de predicción. Primero estimamos la tasa de avistamientos y el conteo, y luego los multiplicamos para obtener una estimación de la abundancia relativa. Comencemos agregando las variables de esfuerzo a la cuadrícula de predicción para una lista de verificación estándar de eBird en el momento óptimo del día para detectar al Zorzal de Swainson. Recordemos que, según la función predict-effort, determinamos que el momento óptimo del día para detectar al Zorzal de Swainson era alrededor de las 6:37 a. m.

```{r}
#| label: abundance-predict-grid
pred_grid_eff <- pred_grid |> 
  mutate(observation_date = ymd("2023-06-15"),
         year = year(observation_date),
         day_of_year = yday(observation_date),
         # determinado como tiempo óptimo para la detección en el capítulo previo
         hours_of_day = 6.6,
         effort_distance_km = 2,
         effort_hours = 1,
         effort_speed_kmph = 2,
         number_observers = 1)
```

Ahora podemos estimar la tasa de encuentros calibrada y el recuento para cada punto de la cuadrícula de predicción. También incluimos una estimación binaria del límite de distribución.

```{r}
#| label: abundance-predict-predict
# estimar tasa de encuentro
pred_er <- predict(er_model, data = pred_grid_eff, type = "response")
pred_er <- pred_er$predictions[, 2]
# definir límite de rango
pred_binary <- as.integer(pred_er > threshold)
# aplciar calibración
pred_er_cal <- predict(calibration_model, 
                       data.frame(pred = pred_er), 
                       type = "response") |> 
  as.numeric()
# restringir a 0-1
pred_er_cal[pred_er_cal < 0] <- 0
pred_er_cal[pred_er_cal > 1] <- 1

# añadir tasa de encuentro predicha requerida para los estimados de conteo
pred_grid_eff$predicted_er <- pred_er
# conteos estimados
pred_count <- predict(count_model, data = pred_grid_eff, type = "response")
pred_count <- pred_count$predictions

# combinar predicciones con coordenadas de la cuadrícula de predicción
predictions <- data.frame(cell_id = pred_grid_eff$cell_id,
                          x = pred_grid_eff$x,
                          y = pred_grid_eff$y,
                          in_range = pred_binary, 
                          encounter_rate = pred_er_cal,
                          count = pred_count)
```

A continuación, agregamos una columna para la estimación de abundancia relativa (el producto de las estimaciones de tasa de encuentro y conteo) y convertimos estas estimaciones a formato ráster.

```{r}
#| label: abundance-predict-raster
# añadir estimados de abundancia relativa
predictions$abundance <- predictions$encounter_rate * predictions$count

# rasterizar
layers <- c("in_range", "encounter_rate", "count", "abundance")
r_pred <- predictions |> 
  # convertir a espacial 
  st_as_sf(coords = c("x", "y"), crs = crs) |> 
  select(all_of(layers)) |> 
  # rasterizar
  rasterize(r, field = layers)
print(r_pred)
```

Finalmente, generaremos un mapa de abundancia relativa. Los valores que se muestran en este mapa representan el número esperado de Zorzales de Swainson avistados por un observador promedio de eBird que realice un conteo itinerante de 2 km durante 1 hora, comenzando aproximadamente a las 6:37 a. m. del 15 de junio de 2023. Dado que la detectabilidad no es perfecta, prevemos que la abundancia real de Zorzales de Swainson sea mayor que estos valores, pero sin estimar directamente la tasa de detección, es difícil precisar cuánto mayor.

Antes de generar el mapa de abundancia relativa, lo multiplicaremos por la capa `in_range`, lo que producirá un mapa que mostrará una abundancia relativa de cero donde el modelo predice que no hay presencia de Zorzales de Swainson.

```{r}
#| label: abundance-predict-map
#| fig.asp: 1.15
par(mar = c(4, 0.25, 0.25, 0.25))
# definir área del plot
plot(study_region, col = NA, border = NA)
plot(ne_land, col = "#cfcfcf", border = "#888888", lwd = 0.5, add = TRUE)

# definir quiebres de cuantiles, excluyendo los ceros
brks <- ifel(r_pred[["abundance"]] > 0, r_pred[["abundance"]], NA) |> 
  global(fun = quantile, 
         probs = seq(0, 1, 0.1), na.rm = TRUE) |> 
  as.numeric() |> 
  unique()
# etiquetar los valores mínimos, medios y máximos
lbls <- round(c(min(brks), median(brks), max(brks)), 2)
# paleta de colores de Status & Trends 
pal <- ebirdst_palettes(length(brks) - 1)
plot(r_pred[["abundance"]], 
     col = c("#e6e6e6", pal), breaks = c(0, brks), 
     maxpixels = ncell(r_pred),
     legend = FALSE, axes = FALSE, bty = "n",
     add = TRUE)

# bordes
plot(ne_state_lines, col = "#ffffff", lwd = 0.75, add = TRUE)
plot(ne_country_lines, col = "#ffffff", lwd = 1.5, add = TRUE)
plot(study_region, border = "#000000", col = NA, lwd = 1, add = TRUE)
box()

# leyenda
par(new = TRUE, mar = c(0, 0, 0, 0))
title <- "Abundancia relativa Zorzal de Swainson (Junio 2023)"
image.plot(zlim = c(0, 1), legend.only = TRUE, 
           col = pal, breaks = seq(0, 1, length.out = length(brks)),
           smallplot = c(0.25, 0.75, 0.03, 0.06),
           horizontal = TRUE,
           axis.args = list(at = c(0, 0.5, 1), labels = lbls,
                            fg = "black", col.axis = "black",
                            cex.axis = 0.75, lwd.ticks = 0.5,
                            padj = -1.5),
           legend.args = list(text = title,
                              side = 3, col = "black",
                              cex = 1, line = 0))
```
